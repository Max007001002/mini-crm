# Мини-CRM распределения лидов между операторами

Небольшой сервис на FastAPI + SQLAlchemy + SQLite для распределения обращений лидов между операторами по источникам с учётом лимитов нагрузки и весов.

## Запуск

### Локально

```bash
python -m venv .venv
source .venv/bin/activate 

pip install -r requirements.txt

uvicorn app.main:app --reload --host 0.0.0.0 --port 8000
```

После запуска:

- API: http://localhost:8000  
- Swagger UI: http://localhost:8000/docs  
- ReDoc: http://localhost:8000/redoc  

### Docker

```bash
docker build -t mini-crm .
docker run --rm -p 8000:8000 mini-crm
```

### Миграции (Alembic)

- Настройки: `alembic.ini` по умолчанию указывает на `sqlite:///./app.db`. Можно переопределить `DATABASE_URL`.
- Применить миграции: `alembic upgrade head`.
- Сгенерировать новую ревизию по моделям (при необходимости): `alembic revision --autogenerate -m "..."` — перед этим убедитесь, что `DATABASE_URL` указывает на чистую базу или на ту, что хотите сравнить.

## Модель данных

### Operator

- `id` — PK.
- `name` — уникальное имя.
- `active` — активен / не активен (может ли получать новые обращения).
- `max_load` — максимальное количество активных обращений.
- `source_configs` — связи с источниками (веса).
- `contacts` — обращения, назначенные оператору.

### Lead

- `id` — PK.
- `external_id` — внешний идентификатор (телефон, email, id пользователя и т.п.), по нему считаем, что обращения относятся к одному лиду.
- `name` — имя лида.
- `created_at` — дата создания.
- `contacts` — обращения лида.

### Source

- `id` — PK.
- `name` — название источника (бота).
- `code` — короткий код (опционально).
- `operator_configs` — список конфигураций с операторами.
- `contacts` — обращения из этого источника.

### SourceOperatorConfig

- `source_id` — FK → Source.
- `operator_id` — FK → Operator.
- `weight` — вес оператора для источника.
- Уникальная пара `(source_id, operator_id)`.

### Contact

- `lead_id` — FK → Lead.
- `source_id` — FK → Source.
- `operator_id` — FK → Operator (может быть `NULL`, если подходящего оператора нет).
- `created_at` — время создания.
- `is_active` — признак активного обращения.
- `message` — текст/комментарий.

**Нагрузка оператора** — это количество записей Contact с данным `operator_id` и `is_active = true`. Лимит `max_load` — максимум таких активных обращений.

## Алгоритм распределения

### Как определяем, что обращения принадлежат одному и тому же лиду

Для этого используется поле `Lead.external_id`.  
В эндпоинте регистрации обращения приходит `lead_external_id`:

1. Ищем лида с таким `external_id`.
2. Если найден — используем его.
3. Если не найден — создаём нового.

Так один и тот же клиент может писать из разных ботов, но все его обращения останутся связаны с одним лидом.

### Как учитываются веса операторов по источникам

Для конкретного `source_id`:

1. Берём все `SourceOperatorConfig` этого источника.
2. Отбрасываем операторы с `weight <= 0`.
3. Считаем сумму весов `total_weight`.
4. Выбираем случайно оператора по распределению `weight / total_weight`:
   - генерируем случайное число `r` от `1` до `total_weight`,
   - идём по списку, накапливая сумму весов,
   - оператор, на котором сумма впервые стала `>= r`, считается выбранным.

Это даёт “в среднем” нужные доли по весам.

### Как учитываются лимиты нагрузки

Перед выбором оператора для источника:

1. Формируем список операторов, для которых:
   - `active = true`;
   - текущая нагрузка (число активных контактов) < `max_load`.
2. Лотерея по весам проводится только среди этого списка.
3. После выбора оператора алгоритм ещё раз проверяет текущую нагрузку на всякий случай:
   - если лимит уже достигнут, оператор убирается из кандидатов и выбор повторяется;
   - если кандидаты закончились — подходящих операторов нет.

### Что происходит, если подходящих операторов нет

Если после всех фильтров и проверок не остаётся ни одного оператора:

- создаётся `Contact` с `operator_id = NULL`,
- в ответе API поле `operator` будет `null`.

То есть обращения не теряются, просто остаются без назначенного оператора (можно разбирать вручную или отдельной логикой).

## API

### Управление операторами

- `POST /operators` — создать оператора.
- `GET /operators` — список операторов.
- `PATCH /operators/{id}` — изменить активность и/или лимит (и при желании имя).

### Настройка распределения по источникам

- `POST /sources` — создать источник (бота).
- `GET /sources` — список источников.
- `GET /sources/{id}` — информация об источнике + операторы с весами.
- `PUT /sources/{id}/operators` — задать список операторов и их веса для источника (полная перезапись).

### Регистрация обращения

- `POST /contacts`

Тело:

```json
{
  "lead_external_id": "user-123",
  "lead_name": "Иван",
  "source_id": 1,
  "message": "Хочу узнать детали"
}
```

Внутри:

1. найти или создать лида по `lead_external_id`;
2. проверить, что источник существует;
3. подобрать оператора с учётом активности, лимита и весов;
4. создать `Contact`.

В ответ возвращается `Contact` с вложенными `lead`, `source`, `operator` (если оператор есть).

### Просмотр состояния

- `GET /leads` — список лидов и их обращений (для каждого лида видны все его обращения из разных источников).
- `GET /stats/operators` — простая статистика: сколько обращений у каждого оператора по источникам.

## Тесты

Тесты находятся в `tests/test_distribution.py`:

- проверяют, что оператор с большим весом статистически получает больше обращений;
- проверяют, что лимит `max_load` не превышается и часть обращений при жёстких лимитах остаётся без оператора.

Запуск:

```bash
pytest
```

## Примечания

- Понятие “активности” обращения реализовано через поле `Contact.is_active`; сейчас оно всегда `true` при создании. В реальном проекте можно добавить эндпоинт для закрытия обращения (перевод в `false`), чтобы освобождать лимит операторов.
